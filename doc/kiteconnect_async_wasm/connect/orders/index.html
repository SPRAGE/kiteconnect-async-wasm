<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Orders Module"><title>kiteconnect_async_wasm::connect::orders - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="kiteconnect_async_wasm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../../../static.files/storage-82c7156e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../kiteconnect_async_wasm/index.html">kiteconnect_<wbr>async_<wbr>wasm</a><span class="version">1.0.6</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module orders</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#orders-module" title="Orders Module">Orders Module</a><ul><li><a href="#overview" title="Overview">Overview</a></li><li><a href="#key-features" title="Key Features">Key Features</a></li><li><a href="#available-methods" title="Available Methods">Available Methods</a></li><li><a href="#usage-examples" title="Usage Examples">Usage Examples</a></li><li><a href="#data-models" title="Data Models">Data Models</a></li><li><a href="#error-handling" title="Error Handling">Error Handling</a></li><li><a href="#order-validation" title="Order Validation">Order Validation</a></li><li><a href="#performance-considerations" title="Performance Considerations">Performance Considerations</a></li><li><a href="#rate-limiting" title="Rate Limiting">Rate Limiting</a></li><li><a href="#thread-safety" title="Thread Safety">Thread Safety</a></li><li><a href="#migration-from-v102" title="Migration from v1.0.2">Migration from v1.0.2</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In kiteconnect_<wbr>async_<wbr>wasm::<wbr>connect</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">kiteconnect_async_wasm</a>::<wbr><a href="../index.html">connect</a></div><h1>Module <span>orders</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/kiteconnect_async_wasm/connect/orders.rs.html#1-989">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="orders-module"><a class="doc-anchor" href="#orders-module">§</a>Orders Module</h2>
<p>This module provides comprehensive order management capabilities for the KiteConnect API v1.0.3,
offering complete control over trade execution with both simple and advanced order types.</p>
<h3 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h3>
<p>The orders module is the core component for executing trades on the KiteConnect platform.
It provides access to order placement, modification, cancellation, and monitoring with
both legacy JSON-based and modern strongly-typed APIs for enhanced developer experience.</p>
<h3 id="key-features"><a class="doc-anchor" href="#key-features">§</a>Key Features</h3><h4 id="-dual-api-support"><a class="doc-anchor" href="#-dual-api-support">§</a>🔄 <strong>Dual API Support</strong></h4>
<ul>
<li><strong>Legacy API</strong>: Returns <code>JsonValue</code> for backward compatibility</li>
<li><strong>Typed API</strong>: Returns structured types with compile-time safety (methods ending in <code>_typed</code>)</li>
</ul>
<h4 id="-complete-order-management"><a class="doc-anchor" href="#-complete-order-management">§</a>📊 <strong>Complete Order Management</strong></h4>
<ul>
<li><strong>Order Placement</strong>: Market, limit, stop-loss, and bracket orders</li>
<li><strong>Order Modification</strong>: Update price, quantity, and order parameters</li>
<li><strong>Order Cancellation</strong>: Cancel pending orders and exit positions</li>
<li><strong>Order Monitoring</strong>: Real-time status updates and fill information</li>
</ul>
<h4 id="-advanced-order-types"><a class="doc-anchor" href="#-advanced-order-types">§</a>💡 <strong>Advanced Order Types</strong></h4>
<ul>
<li><strong>Regular Orders</strong>: Basic buy/sell orders</li>
<li><strong>Bracket Orders</strong>: Auto stop-loss and profit booking</li>
<li><strong>Cover Orders</strong>: Built-in stop-loss protection</li>
<li><strong>Iceberg Orders</strong>: Large order execution in smaller chunks</li>
<li><strong>GTT Orders</strong>: Good Till Triggered conditional orders</li>
</ul>
<h4 id="-builder-patterns"><a class="doc-anchor" href="#-builder-patterns">§</a>🛠️ <strong>Builder Patterns</strong></h4>
<ul>
<li><strong>OrderBuilder</strong>: Fluent API for constructing orders</li>
<li><strong>BracketOrderBuilder</strong>: Specialized builder for bracket orders</li>
<li><strong>Type Safety</strong>: Compile-time validation of order parameters</li>
</ul>
<h3 id="available-methods"><a class="doc-anchor" href="#available-methods">§</a>Available Methods</h3><h4 id="order-placement"><a class="doc-anchor" href="#order-placement">§</a>Order Placement</h4>
<ul>
<li><a href="../struct.KiteConnect.html#method.place_order" title="method kiteconnect_async_wasm::connect::KiteConnect::place_order"><code>place_order()</code></a> / <a href="../struct.KiteConnect.html#method.place_order_typed" title="method kiteconnect_async_wasm::connect::KiteConnect::place_order_typed"><code>place_order_typed()</code></a> - Place new orders</li>
<li><a href="../struct.KiteConnect.html#method.modify_order" title="method kiteconnect_async_wasm::connect::KiteConnect::modify_order"><code>modify_order()</code></a> - Modify existing orders</li>
<li><a href="../struct.KiteConnect.html#method.cancel_order" title="method kiteconnect_async_wasm::connect::KiteConnect::cancel_order"><code>cancel_order()</code></a> - Cancel pending orders</li>
</ul>
<h4 id="order-information"><a class="doc-anchor" href="#order-information">§</a>Order Information</h4>
<ul>
<li><a href="../struct.KiteConnect.html#method.orders" title="method kiteconnect_async_wasm::connect::KiteConnect::orders"><code>orders()</code></a> / <a href="../struct.KiteConnect.html#method.orders_typed" title="method kiteconnect_async_wasm::connect::KiteConnect::orders_typed"><code>orders_typed()</code></a> - Get all orders</li>
<li><a href="../struct.KiteConnect.html#method.order_history" title="method kiteconnect_async_wasm::connect::KiteConnect::order_history"><code>order_history()</code></a> - Get order execution history</li>
<li><a href="../struct.KiteConnect.html#method.trades" title="method kiteconnect_async_wasm::connect::KiteConnect::trades"><code>trades()</code></a> / <a href="../struct.KiteConnect.html#method.trades_typed" title="method kiteconnect_async_wasm::connect::KiteConnect::trades_typed"><code>trades_typed()</code></a> - Get trade book</li>
</ul>
<h4 id="position-management"><a class="doc-anchor" href="#position-management">§</a>Position Management</h4>
<ul>
<li><a href="../struct.KiteConnect.html#method.convert_position" title="method kiteconnect_async_wasm::connect::KiteConnect::convert_position"><code>convert_position()</code></a> - Convert product types</li>
<li>Position tracking and P&amp;L monitoring</li>
</ul>
<h3 id="usage-examples"><a class="doc-anchor" href="#usage-examples">§</a>Usage Examples</h3><h4 id="basic-order-placement"><a class="doc-anchor" href="#basic-order-placement">§</a>Basic Order Placement</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kiteconnect_async_wasm::connect::KiteConnect;
<span class="kw">use </span>kiteconnect_async_wasm::models::orders::OrderParams;
<span class="kw">use </span>kiteconnect_async_wasm::models::common::{Exchange, TransactionType, OrderType, Product, Validity};

<span class="kw">let </span>client = KiteConnect::new(<span class="string">"api_key"</span>, <span class="string">"access_token"</span>);

<span class="comment">// Method 1: Direct order parameters
</span><span class="kw">let </span>order_params = OrderParams {
    exchange: Exchange::NSE,
    trading_symbol: <span class="string">"RELIANCE"</span>.to_string(),
    transaction_type: TransactionType::BUY,
    quantity: <span class="number">10</span>,
    order_type: OrderType::LIMIT,
    product: Product::CNC,
    price: <span class="prelude-val">Some</span>(<span class="number">2500.0</span>),
    validity: <span class="prelude-val">Some</span>(Validity::DAY),
    disclosed_quantity: <span class="prelude-val">None</span>,
    trigger_price: <span class="prelude-val">None</span>,
    tag: <span class="prelude-val">Some</span>(<span class="string">"MyOrder"</span>.to_string()),
    squareoff: <span class="prelude-val">None</span>,
    stoploss: <span class="prelude-val">None</span>,
    trailing_stoploss: <span class="prelude-val">None</span>,
    market_protection: <span class="prelude-val">None</span>,
    iceberg_legs: <span class="prelude-val">None</span>,
    iceberg_quantity: <span class="prelude-val">None</span>,
    auction_number: <span class="prelude-val">None</span>,
};

<span class="kw">let </span>response = client.place_order_typed(<span class="string">"regular"</span>, <span class="kw-2">&amp;</span>order_params).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="macro">println!</span>(<span class="string">"🎯 Order placed successfully!"</span>);
<span class="macro">println!</span>(<span class="string">"   Order ID: {}"</span>, response.order_id);</code></pre></div>
<h4 id="using-order-builder-recommended"><a class="doc-anchor" href="#using-order-builder-recommended">§</a>Using Order Builder (Recommended)</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kiteconnect_async_wasm::connect::KiteConnect;
<span class="kw">use </span>kiteconnect_async_wasm::models::orders::OrderBuilder;
<span class="kw">use </span>kiteconnect_async_wasm::models::common::{Exchange, TransactionType, OrderType, Product, Validity};

<span class="kw">let </span>client = KiteConnect::new(<span class="string">"api_key"</span>, <span class="string">"access_token"</span>);

<span class="comment">// Fluent builder pattern for better ergonomics
</span><span class="kw">let </span>order = OrderBuilder::new()
    .trading_symbol(<span class="string">"TCS"</span>)
    .exchange(Exchange::NSE)
    .transaction_type(TransactionType::BUY)
    .quantity(<span class="number">5</span>)
    .order_type(OrderType::MARKET)
    .product(Product::MIS)
    .validity(Validity::DAY)
    .tag(<span class="string">"QuickBuy"</span>)
    .build()<span class="question-mark">?</span>;

<span class="kw">let </span>response = client.place_order_typed(<span class="string">"regular"</span>, <span class="kw-2">&amp;</span>order).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="macro">println!</span>(<span class="string">"🚀 Market order executed!"</span>);
<span class="macro">println!</span>(<span class="string">"   Order ID: {}"</span>, response.order_id);</code></pre></div>
<h4 id="advanced-order-types"><a class="doc-anchor" href="#advanced-order-types">§</a>Advanced Order Types</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kiteconnect_async_wasm::connect::KiteConnect;
<span class="kw">use </span>kiteconnect_async_wasm::models::orders::{OrderBuilder, BracketOrderBuilder};
<span class="kw">use </span>kiteconnect_async_wasm::models::common::{Exchange, TransactionType, OrderType, Product};

<span class="kw">let </span>client = KiteConnect::new(<span class="string">"api_key"</span>, <span class="string">"access_token"</span>);

<span class="comment">// Stop-Loss Order
</span><span class="kw">let </span>sl_order = OrderBuilder::new()
    .trading_symbol(<span class="string">"INFY"</span>)
    .exchange(Exchange::NSE)
    .transaction_type(TransactionType::SELL)
    .quantity(<span class="number">20</span>)
    .order_type(OrderType::SL)
    .product(Product::MIS)
    .price(<span class="number">1450.0</span>)
    .trigger_price(<span class="number">1440.0</span>)
    .build()<span class="question-mark">?</span>;

<span class="kw">let </span>sl_response = client.place_order_typed(<span class="string">"regular"</span>, <span class="kw-2">&amp;</span>sl_order).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="macro">println!</span>(<span class="string">"🛡️ Stop-loss order placed: {}"</span>, sl_response.order_id);

<span class="comment">// Bracket Order (Buy with auto profit booking and stop-loss)
</span><span class="kw">let </span>bracket_order = BracketOrderBuilder::new()
    .trading_symbol(<span class="string">"HDFC"</span>)
    .exchange(Exchange::NSE)
    .transaction_type(TransactionType::BUY)
    .quantity(<span class="number">10</span>)
    .price(<span class="number">1600.0</span>)
    .squareoff(<span class="number">1650.0</span>)    <span class="comment">// Take profit at +50
    </span>.stoploss(<span class="number">1580.0</span>)     <span class="comment">// Stop loss at -20
    </span>.trailing_stoploss(<span class="number">5.0</span>) <span class="comment">// Trail by 5 points
    </span>.build()<span class="question-mark">?</span>;

<span class="kw">let </span>bo_response = client.place_order_typed(<span class="string">"bo"</span>, <span class="kw-2">&amp;</span>bracket_order.order_params).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="macro">println!</span>(<span class="string">"🎯 Bracket order placed: {}"</span>, bo_response.order_id);

<span class="comment">// Iceberg Order (Large order in small chunks)
</span><span class="kw">let </span>iceberg_order = OrderBuilder::new()
    .trading_symbol(<span class="string">"SBIN"</span>)
    .exchange(Exchange::NSE)
    .transaction_type(TransactionType::BUY)
    .quantity(<span class="number">1000</span>)        <span class="comment">// Total quantity
    </span>.order_type(OrderType::LIMIT)
    .product(Product::CNC)
    .price(<span class="number">250.0</span>)
    .iceberg(<span class="number">10</span>, <span class="number">100</span>)      <span class="comment">// 10 legs of 100 shares each
    </span>.build()<span class="question-mark">?</span>;

<span class="kw">let </span>iceberg_response = client.place_order_typed(<span class="string">"iceberg"</span>, <span class="kw-2">&amp;</span>iceberg_order).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="macro">println!</span>(<span class="string">"🧊 Iceberg order placed: {}"</span>, iceberg_response.order_id);</code></pre></div>
<h4 id="order-monitoring-and-management"><a class="doc-anchor" href="#order-monitoring-and-management">§</a>Order Monitoring and Management</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kiteconnect_async_wasm::connect::KiteConnect;
<span class="kw">use </span>kiteconnect_async_wasm::models::orders::OrderStatus;

<span class="kw">let </span>client = KiteConnect::new(<span class="string">"api_key"</span>, <span class="string">"access_token"</span>);

<span class="comment">// Get all orders for the day
</span><span class="kw">let </span>orders = client.orders_typed().<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">println!</span>(<span class="string">"📋 Today's Orders ({}):"</span>, orders.len());
<span class="macro">println!</span>(<span class="string">"================================"</span>);

<span class="kw">for </span>order <span class="kw">in </span><span class="kw-2">&amp;</span>orders {
    <span class="kw">let </span>status_icon = <span class="kw">match </span>order.status {
        OrderStatus::Complete =&gt; <span class="string">"✅"</span>,
        OrderStatus::Open | OrderStatus::TriggerPending =&gt; <span class="string">"⏳"</span>,
        OrderStatus::Cancelled =&gt; <span class="string">"❌"</span>,
        OrderStatus::Rejected =&gt; <span class="string">"🚫"</span>,
        <span class="kw">_ </span>=&gt; <span class="string">"❓"</span>,
    };

    <span class="macro">println!</span>(<span class="string">"{} {} ({:?})"</span>, status_icon, order.order_id, order.status);
    <span class="macro">println!</span>(<span class="string">"   📊 {:?} {} {} @ ₹{:.2}"</span>,
        order.transaction_type,
        order.quantity,
        order.trading_symbol,
        order.price);

    <span class="kw">if </span>order.is_partially_filled() {
        <span class="macro">println!</span>(<span class="string">"   📈 Partial fill: {}/{} ({:.1}%)"</span>,
            order.filled_quantity,
            order.quantity,
            order.fill_percentage());
    }

    <span class="kw">if </span>order.is_complete() &amp;&amp; order.filled_quantity &gt; <span class="number">0 </span>{
        <span class="macro">println!</span>(<span class="string">"   💰 Avg fill price: ₹{:.2}"</span>,
            order.average_price);
    }
    <span class="macro">println!</span>();
}</code></pre></div>
<h4 id="order-modification-and-cancellation"><a class="doc-anchor" href="#order-modification-and-cancellation">§</a>Order Modification and Cancellation</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kiteconnect_async_wasm::connect::KiteConnect;

<span class="kw">let </span>client = KiteConnect::new(<span class="string">"api_key"</span>, <span class="string">"access_token"</span>);

<span class="kw">let </span>order_id = <span class="string">"210429000000001"</span>; <span class="comment">// Replace with actual order ID

// Modify order price
</span><span class="kw">let </span>modify_result = client.modify_order(
    order_id,
    <span class="string">"regular"</span>,           <span class="comment">// variety
    </span><span class="prelude-val">None</span>,               <span class="comment">// quantity (unchanged)
    </span><span class="prelude-val">Some</span>(<span class="string">"2550.0"</span>),     <span class="comment">// new price
    </span><span class="prelude-val">None</span>,               <span class="comment">// order_type (unchanged)
    </span><span class="prelude-val">None</span>,               <span class="comment">// validity (unchanged)
    </span><span class="prelude-val">None</span>,               <span class="comment">// disclosed_quantity
    </span><span class="prelude-val">None</span>,               <span class="comment">// trigger_price
    </span><span class="prelude-val">None</span>,               <span class="comment">// parent_order_id
</span>).<span class="kw">await</span>;

<span class="kw">match </span>modify_result {
    <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"✅ Order {} modified successfully"</span>, order_id),
    <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">println!</span>(<span class="string">"❌ Failed to modify order: {}"</span>, e),
}

<span class="comment">// Cancel order if modification fails or no longer needed
</span><span class="kw">let </span>cancel_result = client.cancel_order(order_id, <span class="string">"regular"</span>, <span class="prelude-val">None</span>).<span class="kw">await</span>;
<span class="kw">match </span>cancel_result {
    <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"🗑️ Order {} cancelled successfully"</span>, order_id),
    <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">println!</span>(<span class="string">"❌ Failed to cancel order: {}"</span>, e),
}</code></pre></div>
<h4 id="trade-book-analysis"><a class="doc-anchor" href="#trade-book-analysis">§</a>Trade Book Analysis</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kiteconnect_async_wasm::connect::KiteConnect;

<span class="kw">let </span>client = KiteConnect::new(<span class="string">"api_key"</span>, <span class="string">"access_token"</span>);

<span class="comment">// Get all trades for the day
</span><span class="kw">let </span>trades = client.trades_typed().<span class="kw">await</span><span class="question-mark">?</span>;

<span class="macro">println!</span>(<span class="string">"💼 Trade Book Analysis ({} trades):"</span>, trades.len());
<span class="macro">println!</span>(<span class="string">"====================================="</span>);

<span class="kw">let </span><span class="kw-2">mut </span>total_turnover = <span class="number">0.0</span>;
<span class="kw">let </span><span class="kw-2">mut </span>buy_trades = <span class="number">0</span>;
<span class="kw">let </span><span class="kw-2">mut </span>sell_trades = <span class="number">0</span>;

<span class="kw">for </span>trade <span class="kw">in </span><span class="kw-2">&amp;</span>trades {
    <span class="kw">let </span>trade_value = trade.total_value();
    total_turnover += trade_value;

    <span class="kw">if </span>trade.is_buy() {
        buy_trades += <span class="number">1</span>;
    } <span class="kw">else </span>{
        sell_trades += <span class="number">1</span>;
    }

    <span class="macro">println!</span>(<span class="string">"🔄 {} {}: {} @ ₹{:.2} (₹{:.2})"</span>,
        trade.fill_timestamp.format(<span class="string">"%H:%M:%S"</span>),
        trade.trading_symbol,
        <span class="kw">if </span>trade.is_buy() { <span class="string">"BUY" </span>} <span class="kw">else </span>{ <span class="string">"SELL" </span>},
        trade.average_price,
        trade_value);
}

<span class="macro">println!</span>();
<span class="macro">println!</span>(<span class="string">"📊 Summary:"</span>);
<span class="macro">println!</span>(<span class="string">"   Total trades: {} (Buy: {}, Sell: {})"</span>, trades.len(), buy_trades, sell_trades);
<span class="macro">println!</span>(<span class="string">"   Total turnover: ₹{:.2}"</span>, total_turnover);
<span class="macro">println!</span>(<span class="string">"   Average trade size: ₹{:.2}"</span>,
    <span class="kw">if </span>!trades.is_empty() { total_turnover / trades.len() <span class="kw">as </span>f64 } <span class="kw">else </span>{ <span class="number">0.0 </span>});</code></pre></div>
<h3 id="data-models"><a class="doc-anchor" href="#data-models">§</a>Data Models</h3><h4 id="order-types"><a class="doc-anchor" href="#order-types">§</a>Order Types</h4>
<p>The <a href="../../models/orders/order_data/struct.Order.html" title="struct kiteconnect_async_wasm::models::orders::order_data::Order"><code>Order</code></a> struct represents order information with comprehensive status tracking:</p>
<ul>
<li><strong>Order Status</strong>: Open, complete, cancelled, rejected states</li>
<li><strong>Fill Information</strong>: Partial and complete fill tracking</li>
<li><strong>Execution Details</strong>: Average price, timestamps, and exchange data</li>
<li><strong>Order Analysis</strong>: Helper methods for status checking and calculations</li>
</ul>
<h4 id="order-parameters"><a class="doc-anchor" href="#order-parameters">§</a>Order Parameters</h4>
<p>The <a href="../../models/orders/order_params/struct.OrderParams.html" title="struct kiteconnect_async_wasm::models::orders::order_params::OrderParams"><code>OrderParams</code></a> struct defines order placement requirements:</p>
<ul>
<li><strong>Required Fields</strong>: Symbol, exchange, transaction type, quantity</li>
<li><strong>Optional Fields</strong>: Price, validity, disclosed quantity, tags</li>
<li><strong>Advanced Features</strong>: Stop-loss, iceberg, bracket order parameters</li>
<li><strong>Validation</strong>: Built-in parameter validation and error checking</li>
</ul>
<h4 id="trade-information"><a class="doc-anchor" href="#trade-information">§</a>Trade Information</h4>
<p>The <a href="../../models/orders/order_history/struct.Trade.html" title="struct kiteconnect_async_wasm::models::orders::order_history::Trade"><code>Trade</code></a> struct represents executed trades:</p>
<ul>
<li><strong>Execution Data</strong>: Fill price, quantity, and timestamp</li>
<li><strong>Order Linkage</strong>: Connection to parent order information</li>
<li><strong>Value Calculations</strong>: Trade value and commission tracking</li>
<li><strong>Direction Analysis</strong>: Buy/sell identification and analysis</li>
</ul>
<h3 id="error-handling"><a class="doc-anchor" href="#error-handling">§</a>Error Handling</h3>
<p>All methods return <code>Result&lt;T&gt;</code> with comprehensive error information:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kiteconnect_async_wasm::models::common::KiteError;

<span class="kw">match </span>client.place_order_typed(<span class="string">"regular"</span>, <span class="kw-2">&amp;</span>order_params).<span class="kw">await </span>{
    <span class="prelude-val">Ok</span>(response) =&gt; {
        <span class="macro">println!</span>(<span class="string">"✅ Order placed: {}"</span>, response.order_id);
    }
    <span class="prelude-val">Err</span>(KiteError::Authentication(msg)) =&gt; {
        <span class="macro">eprintln!</span>(<span class="string">"🔐 Authentication failed: {}"</span>, msg);
        <span class="comment">// Handle re-authentication
    </span>}
    <span class="prelude-val">Err</span>(KiteError::Api { status, message, .. }) =&gt; {
        <span class="macro">eprintln!</span>(<span class="string">"🚫 Order rejected: {} - {}"</span>, status, message);
        <span class="kw">if </span>status == <span class="string">"429" </span>{
            <span class="macro">eprintln!</span>(<span class="string">"⏱️ Rate limited - please wait before retrying"</span>);
        }
        <span class="comment">// Handle order rejection (insufficient margin, invalid params, etc.)
    </span>}
    <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">eprintln!</span>(<span class="string">"❌ Other error: {}"</span>, e),
}</code></pre></div>
<h3 id="order-validation"><a class="doc-anchor" href="#order-validation">§</a>Order Validation</h3>
<p>The module provides built-in validation for order parameters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>kiteconnect_async_wasm::models::orders::OrderBuilder;
<span class="kw">use </span>kiteconnect_async_wasm::models::common::{Exchange, TransactionType, OrderType, Product};

<span class="comment">// This will fail validation - no price for LIMIT order
</span><span class="kw">let </span>invalid_order = OrderBuilder::new()
    .trading_symbol(<span class="string">"RELIANCE"</span>)
    .exchange(Exchange::NSE)
    .transaction_type(TransactionType::BUY)
    .quantity(<span class="number">10</span>)
    .order_type(OrderType::LIMIT)  <span class="comment">// LIMIT order requires price
    </span>.product(Product::CNC)
    .build(); <span class="comment">// This returns Err("Price is required for LIMIT orders")

</span><span class="kw">match </span>invalid_order {
    <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"Order validated successfully"</span>),
    <span class="prelude-val">Err</span>(e) =&gt; <span class="macro">println!</span>(<span class="string">"Validation error: {}"</span>, e),
}

<span class="comment">// Correct version with price
</span><span class="kw">let </span>valid_order = OrderBuilder::new()
    .trading_symbol(<span class="string">"RELIANCE"</span>)
    .exchange(Exchange::NSE)
    .transaction_type(TransactionType::BUY)
    .quantity(<span class="number">10</span>)
    .order_type(OrderType::LIMIT)
    .product(Product::CNC)
    .price(<span class="number">2500.0</span>)  <span class="comment">// Price provided for LIMIT order
    </span>.build()<span class="question-mark">?</span>;

<span class="macro">println!</span>(<span class="string">"✅ Order validated and ready for placement"</span>);</code></pre></div>
<h3 id="performance-considerations"><a class="doc-anchor" href="#performance-considerations">§</a>Performance Considerations</h3><h4 id="efficient-order-management"><a class="doc-anchor" href="#efficient-order-management">§</a>Efficient Order Management</h4>
<ul>
<li><strong>Batch Operations</strong>: Use <code>tokio::join!</code> for concurrent order operations</li>
<li><strong>Typed APIs</strong>: Use <code>*_typed()</code> methods for better performance and type safety</li>
<li><strong>Builder Patterns</strong>: Use builders for complex orders to avoid parameter errors</li>
</ul>
<h4 id="memory-usage"><a class="doc-anchor" href="#memory-usage">§</a>Memory Usage</h4>
<ul>
<li><strong>Structured Data</strong>: Typed APIs use less memory than JSON parsing</li>
<li><strong>Efficient Calculations</strong>: Built-in helper methods reduce computation overhead</li>
<li><strong>Order Filtering</strong>: Filter orders client-side to reduce data processing</li>
</ul>
<h3 id="rate-limiting"><a class="doc-anchor" href="#rate-limiting">§</a>Rate Limiting</h3>
<p>The module automatically handles rate limiting according to KiteConnect API guidelines:</p>
<ul>
<li><strong>Order APIs</strong>: 10 requests per second for order placement and modification</li>
<li><strong>Query APIs</strong>: 3 requests per second for order and trade queries</li>
<li><strong>Automatic Retry</strong>: Built-in retry mechanism with exponential backoff</li>
<li><strong>Connection Pooling</strong>: HTTP connections are reused for better performance</li>
</ul>
<h3 id="thread-safety"><a class="doc-anchor" href="#thread-safety">§</a>Thread Safety</h3>
<p>All methods are thread-safe and can be called concurrently:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Concurrent order and trade data retrieval
</span><span class="kw">let </span>(orders, trades) = <span class="macro">tokio::try_join!</span>(
    client.orders_typed(),
    client.trades_typed()
)<span class="question-mark">?</span>;

<span class="comment">// Process both datasets concurrently
</span><span class="macro">println!</span>(<span class="string">"Orders: {}, Trades: {}"</span>, orders.len(), trades.len());</code></pre></div>
<h3 id="migration-from-v102"><a class="doc-anchor" href="#migration-from-v102">§</a>Migration from v1.0.2</h3>
<p>All existing methods continue to work. New typed methods provide enhanced features:</p>
<ul>
<li>Replace <code>place_order()</code> with <code>place_order_typed()</code> for structured parameters</li>
<li>Use <code>orders_typed()</code> and <code>trades_typed()</code> for type safety</li>
<li>Leverage <code>OrderBuilder</code> and <code>BracketOrderBuilder</code> for complex orders</li>
<li>Legacy methods remain available for backward compatibility</li>
</ul>
</div></details></section></div></main></body></html>